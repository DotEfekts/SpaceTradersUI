@using Blazored.LocalStorage;
@using TradeCommander.CommandHandlers;
@inherits LayoutComponentBase
@implements IDisposable
@inject HttpClient Http
@inject UserProvider UserProvider
@inject ConsoleOutput Console
@inject CommandManager Commands
@inject IJSRuntime JS
@inject ISyncLocalStorageService LocalStorage


@if (!gameOffline.HasValue || (!gameOffline.Value && !UserProvider.StartingDetailsChecked))
{
    <div class="loading">
        <img src="img/spacetraders-logo.png" alt="SpaceTraders Logo" />
        <div class="title">
            <span class="text1">Trade</span>
            <span class="text2">Commander</span>
        </div>
        <span class="subtitle">Is Loading...</span>
    </div>
}
else if (gameOffline.HasValue && gameOffline.Value)
{
    <div class="loading">
        <img src="img/spacetraders-logo.png" alt="SpaceTraders Logo" />
        <div class="title">
            <span class="text1">Trade</span>
            <span class="text2">Commander</span>
        </div>
        <span class="subtitle">SpaceTraders API is offline.<br />Please refresh to retry.</span>
    </div>
}
else
{
    <div class="page">
        <div class="info">
            @if (UserProvider.UserDetails != null)
            {
                <div class="info-bar">
                    <span class="left">User: @UserProvider.UserDetails.Username</span>
                    <span class="right">Credits: @UserProvider.UserDetails.Credits.ToString("N0")</span>
                </div>
                <div class="ships"><TradeCommander.Pages.Ships></TradeCommander.Pages.Ships></div>
            }
            <div class="console">
                <div class="output">
                    <p class="console-text" id="console">@Console.Output</p>
                </div>
                <div class="command-input">
                    <span>&gt;</span><input type="text" name="command-input" id="command-input" @bind="commandInput" @bind:event="oninput" @onkeydown="ReadCommand" />
                </div>
            </div>
        </div>
        <div class="body">
            @if (UserProvider.UserDetails != null)
            {
                <div class="content">
                    @Body
                </div>
            }
        </div>
    </div>
}

@code
{
    private bool? gameOffline = null;

    private string commandInput = "";

    private List<string> commandHistory = new List<string>();
    private int historyIndex = -1;

    private Queue<string> commandQueue = new Queue<string>();
    private bool queueRunning = false;

    private bool initialMessageShown = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var result = await Http.GetAsync("/game/status");
            gameOffline = result.StatusCode != System.Net.HttpStatusCode.OK;
        }
        catch (Exception) { gameOffline = true; }
        finally { StateHasChanged(); }

        Console.OutputUpdated += OutputUpdated;
        UserProvider.UserUpdated += UserUpdated;

        base.OnInitialized();
    }

    public void Dispose()
    {
        Console.OutputUpdated -= OutputUpdated;
        UserProvider.UserUpdated -= UserUpdated;
    }

    private void OutputUpdated(object sender, string type)
    {
        StateHasChanged();
        JS.InvokeVoidAsync("scrollConsoleDown");
    }

    private void UserUpdated(object sender, UserEventArgs eventArgs)
    {
        if (eventArgs.UserDetails == null)
            initialMessageShown = false;

        if (!eventArgs.IsInitialCheck)
            commandHistory.Clear();

        if (eventArgs.UserDetails != null && LocalStorage.ContainKey("CommandHistory." + eventArgs.UserDetails.Username))
            commandHistory = LocalStorage.GetItem<List<string>>("CommandHistory." + eventArgs.UserDetails.Username);

        historyIndex = -1;

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!initialMessageShown && UserProvider.StartingDetailsChecked && gameOffline.HasValue)
        {
            initialMessageShown = true;
            if (UserProvider.UserDetails == null)
            {
                await Console.WriteLine("User details required.", 500);
                await Console.WriteLine("Login command: LOGIN <Username> <Token>", 250);
                await Console.WriteLine("Signup command: SIGNUP <Username>", 250);
            }
            else
            {
                Console.WriteLine("Welcome back, " + UserProvider.Username + ".");
                StateHasChanged();
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task ReadCommand(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            var command = commandInput;
            commandInput = "";

            string historyCommand = null;
            if (historyIndex != -1)
                historyCommand = commandHistory[historyIndex];
            historyIndex = -1;

            if (command != historyCommand && !string.IsNullOrWhiteSpace(command) && UserProvider.Username != null)
            {

                commandHistory.Insert(0, command);
                if (commandHistory.Count > 100)
                    commandHistory.RemoveRange(100, commandHistory.Count - 100);

                LocalStorage.SetItem("CommandHistory." + UserProvider.Username, commandHistory);
            }


            await AddToCommandQueue(command);
        }
        else if (e.Code == "ArrowUp")
        {

            if (historyIndex < commandHistory.Count - 1)
            {
                historyIndex++;
                commandInput = commandHistory[historyIndex];
                StateHasChanged();
                await JS.InvokeVoidAsync("moveCaretToEnd");
            }
        }
        else if (e.Code == "ArrowDown")
        {
            if (historyIndex >= 0)
            {
                historyIndex--;
                if (historyIndex >= 0)
                    commandInput = commandHistory[historyIndex];
                else
                    commandInput = "";
                StateHasChanged();
                await JS.InvokeVoidAsync("moveCaretToEnd");
            }
        }
    }

    private async Task AddToCommandQueue(string command)
    {
        commandQueue.Enqueue(command);

        if (!queueRunning)
        {
            queueRunning = true;
            do
            {
                var nextCommand = commandQueue.Dequeue();
                Console.WriteLine("");
                Console.WriteLine("> " + nextCommand);
                await Commands.InvokeCommand(nextCommand, false);
            } while (commandQueue.Any());
            queueRunning = false;
        }
    }
}
